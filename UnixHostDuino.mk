# Include this Makefile to compile an Arduino *.ino file on Linux or MacOS.
#
# Create a 'Makefile' in the sketch folder. For example, for the
# Blink/Blink.ino program, the makefile will be 'Blink/Makefile'.
# The content will look like this:
#
#      APP_NAME := {name of *.ino file}
#      ARDUINO_LIBS := AUnit AceTime {... additional Arduino libraries}
#      include ../../../UnixHostDuino/UnixHostDuino.mk
#
# The 2 required parameters are:
#
#   * APP_NAME: base name of the Arduino sketch file,
#     e.g. 'Blink' not 'Blink.ino'
#   * ARDUINO_LIBS: list of dependent Arduino libraries in sibling directories
#	  to UnixHostDuino (e.g. AUnit). The UnixHostDuino directory is
#	  automatically included.
#
# Optional parameters are:
#
#	* ARDUINO_LIB_DIRS: List of additional locations of Arduino libs, for
#	  example, $(ARDUINO_IDE_DIR)/libraries,
#	  $(ARDUINO_IDE_DIR)/hardware/arduino/avr/libraries,
#	  $(ARDUINO_IDE_DIR)/portable/packages/arduino/hardware/avr/1.8.2/libraries.
#	  (The $(ARDUINO_IDE_DIR) is an example temporary variable containing the
#	  install location of the Arduino IDE. It is not used by UnixHostDuino.mk.)
#   * OBJS: Additional object (*.o) files needed by the binary
#   * GENERATED: A list of files which are generated by a script, and therefore
#     can be deleted by 'make clean'
#	* MORE_CLEAN: Optional user-supplied make-target that performs
#	  additional cleanup (i.e. removing generated directories).
#
# Type 'make -n' to verify.
#
# Type 'make' to create the $(APP_NAME).out program.
#
# Type 'make clean' to remove intermediate files.

# Detect Linux or MacOS

UNAME := $(shell uname)

# UnixHostDuino module directory.
UNIX_HOST_DUINO_DIR := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))
# Assume that there are other libs are siblings to UnixHostDuino
UNIX_HOST_DUINO_LIB_DIR := $(abspath $(UNIX_HOST_DUINO_DIR)/..)

# List of Arduino IDE library folders, both built-in to the Arduino IDE
# and those downloaded later, e.g. in the portable/ directory or .arduino15/
# directory.
SOURCE_DIRS_PATH ?=

# Default modules which are automatically linked in: UnixHostDuino/
DEFAULT_MODULES := $(UNIX_HOST_DUINO_DIR)

# Look for the ARDUINO_LIBS modules under each of the ARDUINO_LIB_DIRS and
# UNIX_HOST_DUINO_LIB_DIR.
APP_MODULES := $(foreach lib,$(SOURCE_DIRS),${UNIX_HOST_DUINO_LIB_DIR}/${lib})
APP_MODULES += \
	$(foreach lib_dir,$(SOURCE_DIRS_PATH),\
		$(foreach lib,$(SOURCE_DIRS),\
			${lib_dir}/${lib}\
		)\
	)

# All dependent modules.
ALL_MODULES := $(DEFAULT_MODULES) $(APP_MODULES)

# Compiler and settings
ifeq ($(UNAME), Linux)
CXX ?= g++
CXXFLAGS ?= -Wall -std=gnu++11 -fno-exceptions -fno-threadsafe-statics -flto
else ifeq ($(UNAME), Darwin)
CXX ?= clang++
CXXFLAGS ?= -std=c++11 -stdlib=libc++ # -Weverything
endif

# pre-processor (-I, -D, etc)
CPPFLAGS_EXPANSION = -I$(module) -I$(module)/src
CPPFLAGS ?=
CPPFLAGS += $(foreach module,$(ALL_MODULES),$(CPPFLAGS_EXPANSION))

# Define a macro to indicate that UnixHostDuino is being used. Defined here
# instead of Arduino.h so that files like 'compat.h' can determine the
# compile-time environment without having to include <Arduino.h>.
CPPFLAGS += -DUNIX_HOST_DUINO

# linker settings (e.g. -lm)
LDFLAGS ?=

# C++ srcs. Old Arduino libraries place the source files at the top level.
# Later Arduino libraries put the source files under the src/ directory.
# Support subdirectory expansions up to 3 levels below 'src/'.
# (There might be a better way to do this using GNU Make but I can't find a
# mechanism that doesn't barf when the 'src/' directory doesn't exist.)
SRCS_EXPANSION = $(wildcard $(module)/*.cpp) \
	$(wildcard $(module)/src/*.cpp) \
	$(wildcard $(module)/src/*/*.cpp) \
	$(wildcard $(module)/src/*/*/*.cpp) \
	$(wildcard $(module)/src/*/*/*/*.cpp)
SRCS := $(foreach module,$(ALL_MODULES),$(SRCS_EXPANSION))
SRCS := ${SRCS} $(wildcard *.cpp) $(wildcard */*.cpp)

# Objects including *.o from *.ino
OBJS += $(SRCS:%.cpp=%.o) $(APP_NAME).o
#vpath %.o ./build
#Note that by removing the @ in front of $(CXX) the compilation will be logged
$(APP_NAME).out: $(OBJS)
	@$(CXX) $(CPPFLAGS) $(CXXFLAGS) -o $@ $(addprefix build/obj/,$(^F)) $(LDFLAGS)

$(APP_NAME).o: $(APP_NAME).cpp
	@$(CXX) $(CPPFLAGS) $(CXXFLAGS) -x c++ -c $^ -o build/obj/$(@F)

%.o: %.cpp
	@$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o build/obj/$(@F)

# This simple rule does not capture all header dependencies of a given cpp
# file. Maybe it's better to make each cpp to depend on all headers of a given
# module, and force a recompilation of all cpp files. As far as I understand,
# this is what the Arduino IDE does upon each compile iteration.
%.cpp: %.h

.PHONY: all clean $(MORE_CLEAN)

all: $(APP_NAME).out

clean: $(MORE_CLEAN)
	rm -f $(APP_NAME).out $(GENERATED)
	rm -rf build
